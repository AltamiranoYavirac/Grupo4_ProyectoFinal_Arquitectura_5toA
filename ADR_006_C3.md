# ADR 006: Estructura de Componentes en la Aplicación Flutter (Modelo C3)

*Autores:* Jiménez D. Christopher, Altamirano Cristian, Iza Jordan

*Asignatura:* Arquitectura de Software | 5 DS “A”

### Fecha:
2025-10-20

### Estado:
Aceptado

---

## Contexto
En el desarrollo de la aplicación de recordatorios médicos para personas mayores, es necesario definir una **arquitectura interna clara y modular** dentro del contenedor principal de Flutter.  
La aplicación debe gestionar múltiples responsabilidades: visualización de recordatorios, registro de medicinas y citas, configuración de notificaciones locales, validación de datos y almacenamiento local.  

Para mantener un código mantenible, escalable y fácil de probar, es crucial definir **componentes desacoplados** que cumplan funciones específicas dentro del sistema, evitando dependencias circulares y facilitando la evolución del producto.  
Además, el diseño debe optimizar el rendimiento, ya que la aplicación estará orientada a usuarios mayores que requieren **interfaz fluida, accesible y confiable**.

---

## Decisión
Implementar una **arquitectura modular basada en componentes**, siguiendo el modelo C3, donde cada módulo cumple una función específica dentro del contenedor Flutter:

- **Interfaz de Usuario (UI)**: Pantalla Principal, Gestión de Medicinas, Gestión de Citas, Historial y Configuración.  
- **Servicios de Aplicación**: `RecordatoriosService`, `MedicinesService`, `CitasService` para lógica de negocio y operaciones CRUD.  
- **Gestión de Estado**: `EstadoLocal` implementado con Provider/GetIt para comunicación entre componentes y persistencia de estado.  
- **Infraestructura**: Conexión con SQLite para almacenamiento local y `NotificacionesManager` para gestión de alertas mediante `flutter_local_notifications`.  
- **Validadores**: Módulo utilitario para asegurar la integridad de los datos antes de guardarlos o programar alarmas.

---

## Consecuencias
- Se obtiene una **arquitectura clara, escalable y fácilmente mantenible**, donde cada componente tiene una responsabilidad definida.  
- La **separación de capas** permite realizar pruebas unitarias por módulo (UI, servicios, validadores, etc.).  
- Facilita la **sustitución o mejora** de módulos (por ejemplo, cambiar SQLite por otro almacenamiento local sin afectar la UI).  
- Aumenta la **reutilización de código** entre distintas pantallas y funcionalidades.  
- La curva de aprendizaje para nuevos desarrolladores puede ser mayor, al requerir comprensión de los flujos entre UI, estado y servicios.  
- La comunicación entre componentes requiere una correcta gestión del estado global para evitar inconsistencias.

---

# Alternativas a Considerar

## Alternativa 1: Arquitectura Monolítica Simple

### Pros
- Menor complejidad inicial, ideal para prototipos rápidos.  
- No requiere patrones de inyección de dependencias ni estructuras de módulos.  
- Curva de aprendizaje más baja para equipos pequeños.

### Contras
- Dificultad para escalar o mantener conforme crece el proyecto.  
- Mayor acoplamiento entre vistas y lógica de negocio.  
- Propenso a errores al modificar una parte del sistema, afectando otras.  
- Pruebas unitarias más complejas debido a dependencias cruzadas.  

---

## Alternativa 2: Arquitectura BLoC (Business Logic Component)

### Pros
- Separación estricta entre lógica de negocio y presentación.  
- Facilita pruebas unitarias y control del flujo de datos.  
- Amplio soporte y documentación dentro del ecosistema Flutter.  

### Contras
- Añade complejidad inicial en proyectos pequeños.  
- Requiere escribir más código para manejar flujos de estado simples.  
- No todos los desarrolladores están familiarizados con la arquitectura BLoC.  

---

## Alternativa 3: MVVM (Model-View-ViewModel)

### Pros
- Buena separación entre la vista y la lógica de presentación.  
- Favorece testabilidad y mantenibilidad del código.  
- Compatible con frameworks de estado como Riverpod o MobX.  

### Contras
- Curva de aprendizaje más alta.  
- Puede generar redundancia si no se estructura correctamente.  
- Menos documentación práctica en Flutter comparado con Provider o BLoC.  

---

## Descripción
El modelo C3 propuesto se implementa dentro del contenedor **“Aplicación Flutter”**, siguiendo un enfoque modular:  

- **UI** representa las pantallas principales con widgets reutilizables y accesibles.  
- **Servicios** encapsulan la lógica de negocio y comunicación con las capas inferiores.  
- **Estado Local** administra el flujo de datos entre UI y Servicios.  
- **Validadores** aseguran consistencia antes de almacenar o notificar.  
- **Infraestructura** (SQLite y Notificaciones) soporta el funcionamiento offline y los recordatorios locales.  

Este enfoque ofrece una visión clara de la aplicación a nivel de componentes, promoviendo una arquitectura limpia y mantenible, alineada con los principios de **Clean Architecture** adaptados al entorno Flutter.

---

## Razón de la Decisión
Se adoptó la arquitectura modular del modelo C3 porque equilibra simplicidad y escalabilidad, permitiendo organizar la aplicación de forma clara sin sobrecargarla con patrones complejos.  
La separación de componentes facilita el desarrollo paralelo por distintos miembros del equipo, reduce la posibilidad de errores y favorece la reutilización.  
La implementación con **Provider/GetIt** para el estado mantiene la aplicación ligera y reactiva, ideal para entornos móviles.  
El uso de **servicios dedicados** mejora la trazabilidad del flujo de datos y simplifica la integración con infraestructura local como SQLite y notificaciones.  
Esta estructura proporciona una base sólida para futuras expansiones, como sincronización en la nube o incorporación de nuevos módulos (por ejemplo, seguimiento de presión arterial o historial clínico).
